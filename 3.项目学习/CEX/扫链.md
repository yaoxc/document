# 常识问题
## 1、基于以太坊开发的合约，扫链都要连接以太坊主网来获取交易数据么

基于以太坊开发的合约，**扫链获取交易数据不一定必须连接以太坊主网**，核心取决于你的「业务环境」和「数据需求」—— 开发/测试阶段可使用测试网/本地节点，生产阶段需连接主网（或主网兼容的第三方节点服务）。以下结合交易所项目实际场景，详细说明不同环境的节点选择、使用场景及注意事项：

### 一、核心结论：按环境选择节点，非仅主网
| 环境/场景                | 连接的节点类型                | 核心用途                                                                 | 是否需要主网 |
|--------------------------|-----------------------------|--------------------------------------------------------------------------|--------------|
| 合约开发/单元测试        | 本地测试节点（Ganache/Hardhat） | 快速调试合约逻辑、模拟交易，无需真实网络                                 | ❌ 不需要    |
| 合约测试/功能验证        | 以太坊测试网（Sepolia/Goerli） | 验证合约在真实网络环境的可用性，测试充值/提现等完整流程                   | ❌ 不需要    |
| 交易所生产环境（上币后） | 以太坊主网节点（自建/第三方） | 实时获取主网合约交易数据（如用户充值、合约转账），支撑真实业务           | ✅ 必须      |
| 历史数据补扫/数据分析    | 主网归档节点（第三方服务）    | 批量获取历史区块/交易数据（如补扫某时间段的充值记录）                     | ✅ 必须（主网数据） |

简单说：**仅生产环境需要连接以太坊主网获取真实交易数据，开发/测试阶段可使用本地节点或测试网，避免主网的手续费和不可回滚风险**。

### 二、交易所项目的节点选择策略（最佳实践）
#### 1. 多环境隔离
- 开发环境：使用 Ganache 本地节点，快速调试；
- 测试环境：使用 Sepolia 测试网，验证完整流程；
- 预发布环境：使用主网测试节点（如 Infura 主网），小流量验证；
- 生产环境：使用 Infura + Alchemy 双节点备份（避免单节点故障），配置负载均衡或故障自动切换。

#### 2. 生产环境节点优化
- 双节点备份：同时配置两个不同第三方服务商的主网节点，扫链服务检测到某节点不可用时，自动切换到备用节点；
- 超时控制：设置合理的节点调用超时时间（如 5 秒），避免节点响应慢导致扫链阻塞；
- 限流保护：第三方节点通常有 API 调用限额，需控制扫链频率（如 ETH 主网每 5 秒扫一次区块），避免触发限流。

#### 3. 数据一致性保障
- 主网数据优先：生产环境扫链仅依赖主网节点，确保交易数据的真实性；
- 历史数据补扫：使用归档节点补扫历史数据后，需与主网实时扫链数据合并，避免重复或遗漏。


### 三、常见疑问解答
#### 1. 测试网合约与主网合约的扫链逻辑是否一致？
- 一致！因为测试网与主网的合约交互方式、区块/交易数据格式完全相同，仅节点地址不同。项目中通过「不同 Web3j 实例 + 环境配置」实现隔离，扫链核心逻辑（交易筛选、解析）可复用。

#### 2. 为什么生产环境不推荐自建主网节点？
- 成本高：主网全量数据超 1TB，需高性能服务器（CPU、内存、带宽），且需 24/7 运行；
- 维护复杂：需处理节点同步、故障恢复、数据备份等问题，对运维要求高；
- 第三方节点更稳定：Infura、Alchemy 等服务商提供多区域部署、容灾备份，可用性远超自建节点。

#### 3. 扫链时如何区分主网和测试网的交易？
- 通过「节点环境 + 币种标识」区分：主网扫链服务仅处理主网币种（如 ETH），测试网扫链服务处理测试网币种（如 ETH-TEST），数据存储时也会区分环境，避免混淆。


### 四、总结
基于以太坊的合约扫链，**仅生产环境需要连接以太坊主网**，开发/测试阶段可使用本地节点（Ganache）或测试网（Sepolia），既降低成本又避免风险。核心原则是：**按环境选择节点，确保数据真实性（生产主网）和开发效率（测试/本地节点）的平衡**。

交易所项目中，推荐采用「第三方主网节点 + 多环境隔离 + 双节点备份」的方案，既保证扫链服务的稳定性和数据准确性，又降低运维成本。


## 2、生产环境合约数据为什么都会同步到主网？
生产环境中以太坊合约数据会同步到主网，核心原因是 **以太坊主网是合约的“唯一可信数据层”** —— 合约本质是部署在以太坊区块链上的代码，其所有状态变更（交易、数据存储）都必须通过主网节点共识确认，最终写入不可篡改的区块，才能保证数据的真实性、安全性和去中心化特性。以下结合交易所业务场景，从技术原理、核心价值、同步机制三个维度详细说明：


### 一、核心本质：合约是“区块链上的不可篡改程序”
以太坊合约（如 ERC20 Token 合约）的本质是：**部署在以太坊主网节点上的字节码程序**，其运行和数据存储完全依赖以太坊区块链网络，而非某台中心化服务器。

#### 1. 合约数据的存储载体：区块链账本
合约的所有数据（如用户余额、转账记录、合约配置）都存储在以太坊主网的 **分布式账本** 中，而非本地数据库：
- 账本由全球数十万主网节点共同维护，每个节点都保存完整的账本副本；
- 合约数据以「键值对」形式存储在区块链的「状态树」中（如 ERC20 合约的 `balanceOf(address)` 余额数据，对应 `key=账户地址，value=余额`）；
- 任何节点修改数据都需经过全网共识（PoS 权益证明），篡改单节点数据不会影响全网账本，确保数据不可篡改。

#### 2. 合约数据同步到主网的前提：交易上链
合约数据的变更（如用户转账、授权、提现）必须通过「交易」触发，且交易需上链确认：
- 示例：用户 A 向交易所合约地址转账 1 ETH（充值），流程是：
    1. 用户 A 发起转账交易（签名后发送到主网）；
    2. 主网节点验证交易合法性（签名、余额充足）；
    3. 交易被打包进区块，通过 PoS 共识确认；
    4. 区块写入主网账本，合约数据（用户 A 余额减少、交易所地址余额增加）同步到全网所有节点；
- 只有交易上链并被共识确认，合约数据才会被全网认可（否则视为无效交易）。


### 二、为什么必须同步到主网？（交易所业务核心诉求）
对交易所而言，合约数据同步到主网是「业务可信的基础」，核心价值体现在 3 点：

#### 1. 数据真实性：避免伪造交易/数据
主网的去中心化共识机制确保：
- 任何交易（如用户充值、提币）都无法被伪造（需私钥签名，且全网验证）；
- 合约数据无法被单方面篡改（如交易所不能私自修改用户的 Token 余额，需通过上链交易触发）；
- 这是交易所的核心信任基石 —— 用户相信资产数据是公开透明、不可篡改的，而非由交易所中心化控制。

#### 2. 资产安全性：链上资产与业务资产对齐
交易所的核心业务是「链上资产托管」，合约数据同步到主网是资产安全的前提：
- 用户充值：只有主网确认交易上链，交易所才会给用户账户加余额（避免接收“未确认的虚假交易”）；
- 用户提币：交易所发起提币交易后，需等待主网确认，确保链上资产已转移到用户地址，再更新业务系统余额；
- 若合约数据不同步到主网，链上资产与交易所业务系统的资产会脱节（如用户已提币但链上未确认，导致重复提币）。

#### 3. 公开可追溯：满足合规与审计需求
主网账本是公开透明的，任何人均可查询：
- 合约的所有交易记录（转账、授权、调用）都可通过区块链浏览器（如 Etherscan）查询，便于用户对账；
- 合规审计时，监管机构可通过主网数据验证交易所的资产真实性（如业务系统的用户余额是否与链上合约余额一致）；
- 若数据仅存储在交易所本地，无法提供公开可追溯的证据，不符合金融合规要求。


### 三、合约数据同步到主网的底层机制（简化版）
合约数据并非“主动同步”，而是通过以太坊的「区块生成-共识-广播」机制，自动同步到全网节点，流程如下：

#### 1. 交易广播
- 用户/交易所发起合约交易（如转账、`transferFrom` 调用），签名后发送到主网节点；
- 节点验证交易合法性后，将交易广播到全网其他节点。

#### 2. 区块打包
- 验证者节点（PoS 机制中的质押节点）从交易池中选择合法交易，打包成新区块；
- 区块包含交易列表、前一区块哈希、时间戳等信息，同时包含合约数据的变更（如余额更新）。

#### 3. 共识确认
- 验证者节点通过 PoS 共识机制（质押 ETH 作为担保）对新区块进行投票确认；
- 当区块获得足够多的验证者投票后，视为“最终确认”（ETH 主网通常需 12-30 个区块确认，约 1-3 分钟）。

#### 4. 全网同步
- 确认后的区块被写入主网账本，同时广播到全网所有节点；
- 每个节点收到区块后，更新本地账本和合约状态（如执行合约字节码，更新余额、存储数据等）；
- 最终，全网所有节点的合约数据保持一致（去中心化同步）。


### 四、常见误解澄清
#### 1. “能不能让合约数据不同步到主网？”
- 不能。合约本身是部署在主网的程序，其运行和数据存储完全依赖主网账本；
- 若想让数据不进入主网，本质是“中心化数据库”，而非区块链合约，失去了区块链的可信、不可篡改特性（与普通中心化系统无区别）。

#### 2. “测试网合约数据也会同步吗？”
- 会，但仅同步到测试网的分布式账本（而非主网）；
- 测试网的同步机制与主网一致（区块打包、共识、广播），但测试网代币无真实价值，仅用于开发测试。

#### 3. “同步到主网需要付费吗？”
- 需要。主网交易需支付 Gas 费（ETH 计价），用于激励验证者节点打包交易、维护网络；
- Gas 费高低取决于交易复杂度（如 ERC20 转账 Gas 费较低，复杂合约调用 Gas 费较高）和网络拥堵程度。


### 五、总结
合约数据同步到以太坊主网，本质是「区块链去中心化可信特性的体现」：
- 对技术而言：主网是合约的运行载体，数据同步是区块链的原生机制；
- 对业务而言：主网是交易所资产可信、安全、合规的核心基础；
- 对用户而言：主网提供了公开可追溯的资产证明，避免中心化风险。

这也是为什么交易所生产环境必须连接以太坊主网获取交易数据 —— 只有主网同步的合约数据，才是真实、有效、可信任的，才能支撑充值、提币等核心业务的正常运行。

## 3、扫链需要配置合约地址么？

“扫链”到底要不要配合约地址，取决于你**扫什么**：

| 场景 | 要不要配合约地址 | 原因 |
| --- | --- | --- |
| 纯链上原生转账（BTC、ETH 普通外部账户转账） | ❌ 不需要 | 交易直接记在 coinbase 或普通 tx 里，跟合约无关 |
| 扫**合约事件**（ERC-20 Transfer、Deposit、Swap …） | ✅ 必须配 | 节点只认“地址 + topic”索引，不配地址就扫不到日志 |
| 扫**合约内部状态**（某代币余额、某 NFT 持仓） | ✅ 必须配 | 要 call 合约的 balanceOf / ownerOf 方法 |
| 全链日志暴力拉取（`eth_getLogs` fromBlock~toBlock 不 filter address） | ❌ 可不配 | 会把整条链所有日志拖回来，再本地过滤；性能差，一般不用 |

一句话：  
**只要你的业务是“看某个合约发了什么事件/存了什么数据”，就必须把合约地址写进 filter；否则节点不会返回对应日志。**

# 扫链流程 & 关键实现

## 1. 扫链简化实现

### 一、扫链核心步骤（4步闭环）
1. **创建 Web3j 连接**：连接以太坊节点（主网/测试网）；
2. **确定起始区块高度**：从扫链日志读取历史进度，无则用链上最新高度；
3. **循环扫描区块**：获取区块交易→筛选目标交易（如充值到交易所地址）→解析交易数据；
```java
    /**
     * 这里有配置： Spring 容器初始化完成后自动启动扫链（@PostConstruct）
     */
    @PostConstruct
    public void startScan() { 
        // do scan
    }
```
4. **处理解析结果**：触发业务事件（如用户充值到账）→更新扫链进度。


### 二、关键依赖（Maven）
需引入 Web3j 核心依赖（处理区块链交互）和 Spring 基础依赖（简化开发）：
```xml
<!-- Web3j 核心：区块链交互 -->
<dependency>
    <groupId>org.web3j</groupId>
    <artifactId>core</artifactId>
    <version>4.10.0</version>
</dependency>
<!-- Spring 上下文：依赖注入、生命周期管理 -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.3.20</version>
</dependency>
<!-- 日志：打印扫链日志 -->
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>1.7.36</version>
</dependency>
<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>
    <version>1.2.11</version>
</dependency>
```


### 三、关键代码实现（完整可运行）
#### 1. 步骤1：配置 Web3j 连接（连接以太坊节点）
```java
import org.web3j.protocol.Web3j;
import org.web3j.protocol.http.HttpService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * 配置 Web3j 连接（连接以太坊主网/测试网节点）
 */
@Configuration
public class Web3jConfig {
    // 以太坊主网节点（Infura 示例，替换为自己的 API Key）
    private static final String ETH_MAINNET_URL = "https://mainnet.infura.io/v3/your-api-key";
    // 测试网节点（Sepolia，开发测试用）
    private static final String ETH_TESTNET_URL = "https://sepolia.infura.io/v3/your-api-key";

    /**
     * 创建 Web3j 实例（生产环境用主网，测试用测试网）
     */
    @Bean
    public Web3j web3j() {
        // 生产环境切换为 ETH_MAINNET_URL
        HttpService httpService = new HttpService(ETH_TESTNET_URL);
        // 设置超时时间（避免节点响应慢阻塞）
        httpService.setConnectTimeout(5000);
        httpService.setReadTimeout(5000);
        return Web3j.build(httpService);
    }
}
```

#### 2. 步骤2：扫链日志工具（记录进度，避免重复扫描）
```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

/**
 * 简单扫链日志工具（生产环境可替换为数据库存储）
 */
@Component
public class ScanLogUtil {
    private static final Logger log = LoggerFactory.getLogger(ScanLogUtil.class);
    // 存储每个币种的最新扫描区块（内存级，重启后失效，生产环境用数据库）
    private Long latestBlock = null;
    private final String coinSymbol;

    // 构造器：指定扫链币种
    public ScanLogUtil() {
        this.coinSymbol = "ETH"; // 可改为动态传入（如 USDT）
    }

    /**
     * 获取最新扫描区块高度（无则返回 null）
     */
    public Long getLatestBlock() {
        return latestBlock;
    }

    /**
     * 更新最新扫描区块高度
     */
    public void updateLatestBlock(Long blockNumber) {
        this.latestBlock = blockNumber;
        log.info("{} 扫链进度更新：最新扫描区块 {}", coinSymbol, blockNumber);
    }
}
```

#### 3. 步骤3-4：核心扫链服务（完整流程）
```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.web3j.protocol.Web3j;
import org.web3j.protocol.core.DefaultBlockParameter;
import org.web3j.protocol.core.methods.response.EthBlock;
import org.web3j.utils.Convert;

import javax.annotation.PostConstruct;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 核心扫链服务（4步闭环：连接→起始区块→扫描解析→处理结果）
 */
@Service
public class SimpleBlockScanner {
    private static final Logger log = LoggerFactory.getLogger(SimpleBlockScanner.class);

    @Autowired
    private Web3j web3j; // 步骤1创建的 Web3j 连接

    @Autowired
    private ScanLogUtil scanLogUtil; // 步骤2的扫链日志工具

    @Autowired
    private DepositHandler depositHandler; // 步骤4的交易处理工具

    // 扫链间隔（秒）：主网建议5-10秒，测试网1-3秒
    private static final int SCAN_INTERVAL = 3;

    // 交易所接收地址（筛选目标交易：仅扫描转账到该地址的交易）
    private static final String EXCHANGE_RECEIVE_ADDRESS = "0xYourExchangeWalletAddress";

    // 扫链线程池（单线程：避免多线程重复扫描）
    private final ExecutorService executorService = Executors.newSingleThreadExecutor(
            r -> new Thread(r, "eth-block-scanner")
    );

    /**
     * Spring 容器初始化完成后自动启动扫链（@PostConstruct）
     */
    @PostConstruct
    public void startScan() {
        log.info("===== 以太坊扫链服务启动，扫链间隔：{}秒 =====", SCAN_INTERVAL);
        executorService.submit(this::scanLoop); // 提交扫链循环任务
    }

    /**
     * 扫链循环（核心流程）
     */
    private void scanLoop() {
        // 步骤2：确定起始区块高度
        Long startBlock = getStartBlockNumber();
        Long currentBlock = startBlock;

        // 循环扫描：持续获取区块并解析
        while (!executorService.isShutdown()) {
            try {
                // 步骤3：获取当前区块详情（true=返回完整交易数据）
                EthBlock.Block block = web3j.ethGetBlockByNumber(
                        DefaultBlockParameter.valueOf(currentBlock),
                        true
                ).send().getBlock();

                if (block == null) {
                    log.warn("区块 {} 不存在，跳过", currentBlock);
                    Thread.sleep(SCAN_INTERVAL * 1000);
                    continue;
                }

                // 步骤3：解析区块内所有交易
                parseBlockTransactions(block, currentBlock);

                // 步骤4：更新扫链进度（扫描成功后更新）
                scanLogUtil.updateLatestBlock(currentBlock);

                // 下一个区块
                currentBlock++;

            } catch (Exception e) {
                log.error("扫描区块 {} 失败，3秒后重试", currentBlock, e);
                try {
                    Thread.sleep(3000); // 异常重试间隔
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    break;
                }
            } finally {
                // 扫链间隔：避免频繁调用节点
                try {
                    Thread.sleep(SCAN_INTERVAL * 1000);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
    }

    /**
     * 步骤2：确定起始区块高度
     */
    private Long getStartBlockNumber() {
        // 1. 优先读取历史扫描进度
        Long latestBlock = scanLogUtil.getLatestBlock();
        if (latestBlock != null) {
            return latestBlock + 1; // 上次高度+1，避免重复扫描
        }

        // 2. 无历史进度：获取链上最新区块高度（首次启动）
        try {
            BigInteger latestBlockOnChain = web3j.ethBlockNumber().send().getBlockNumber();
            log.info("首次启动，从链上最新区块 {} 开始扫描", latestBlockOnChain);
            return latestBlockOnChain.longValue();
        } catch (Exception e) {
            log.error("获取链上最新区块失败，默认从 10000000 开始扫描", e);
            return 10000000L; // 兜底起始高度
        }
    }

    /**
     * 步骤3：解析区块内的交易（筛选充值交易）
     */
    private void parseBlockTransactions(EthBlock.Block block, Long blockNumber) {
        log.info("开始解析区块 {}，包含 {} 笔交易", blockNumber, block.getTransactions().size());

        // 遍历区块内所有交易
        for (EthBlock.TransactionResult<?> txResult : block.getTransactions()) {
            EthBlock.TransactionObject tx = (EthBlock.TransactionObject) txResult.get();

            // 筛选目标交易：接收地址是交易所地址（充值交易）
            String toAddress = tx.getTo();
            if (toAddress == null || !toAddress.equalsIgnoreCase(EXCHANGE_RECEIVE_ADDRESS)) {
                continue; // 非目标交易，跳过
            }

            // 解析交易核心信息（ETH 原生转账示例，ERC20 需额外解析 input）
            String txHash = tx.getHash(); // 交易哈希
            String fromAddress = tx.getFrom(); // 转账发起地址
            BigInteger valueWei = tx.getValue(); // 转账金额（Wei 单位）
            BigDecimal valueEth = Convert.fromWei(valueWei.toString(), Convert.Unit.ETHER); // 转为 ETH

            // 步骤4：处理解析结果（触发充值到账逻辑）
            DepositDTO deposit = DepositDTO.builder()
                    .txHash(txHash)
                    .fromAddress(fromAddress)
                    .toAddress(toAddress)
                    .amount(valueEth)
                    .blockNumber(blockNumber)
                    .coinSymbol("ETH")
                    .build();
            depositHandler.handleDeposit(deposit);
        }
    }

    /**
     * 停止扫链服务（应用关闭时调用）
     */
    public void stopScan() {
        log.info("===== 以太坊扫链服务停止 =====");
        executorService.shutdown();
    }
}
```

#### 4. 步骤4：交易结果处理（充值到账逻辑）
```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;

/**
 * 交易处理工具：接收扫链解析结果，触发业务逻辑（如用户充值到账）
 */
@Component
public class DepositHandler {
    private static final Logger log = LoggerFactory.getLogger(DepositHandler.class);

    /**
     * 处理充值交易（核心业务逻辑）
     */
    public void handleDeposit(DepositDTO deposit) {
        // 1. 幂等校验（避免重复处理：查询数据库是否已处理该 txHash）
        if (isTxAlreadyProcessed(deposit.getTxHash())) {
            log.warn("交易 {} 已处理，跳过", deposit.getTxHash());
            return;
        }

        // 2. 业务逻辑：更新用户余额、发送到账通知等（示例）
        log.info("===== 收到充值交易 =====");
        log.info("交易哈希：{}", deposit.getTxHash());
        log.info("发起地址：{}", deposit.getFromAddress());
        log.info("接收地址：{}", deposit.getToAddress());
        log.info("充值金额：{} {}", deposit.getAmount(), deposit.getCoinSymbol());
        log.info("区块高度：{}", deposit.getBlockNumber());

        // 3. 持久化：将充值记录存入数据库（生产环境实现）
        // depositRepository.save(deposit);

        log.info("交易 {} 处理完成", deposit.getTxHash());
    }

    /**
     * 幂等校验：判断交易是否已处理（生产环境查询数据库）
     */
    private boolean isTxAlreadyProcessed(String txHash) {
        // 示例：内存级校验（生产环境替换为数据库查询）
        return false;
    }
}

/**
 * 充值交易DTO：封装解析结果
 */
@lombok.Data
@lombok.Builder
class DepositDTO {
    private String txHash; // 交易哈希
    private String fromAddress; // 发起地址
    private String toAddress; // 接收地址
    private BigDecimal amount; // 充值金额
    private Long blockNumber; // 区块高度
    private String coinSymbol; // 币种符号
}
```


### 四、核心说明
#### 1. 流程简化要点
- 去除多链适配、复杂异常重试，聚焦单币种（ETH）核心流程；
- 扫链日志用内存存储（生产环境替换为数据库，如 `watcher_log` 表）；
- 仅处理 ETH 原生转账（ERC20 需额外解析交易 `input` 字段，见下文扩展）。

#### 2. ERC20 Token 扫链扩展（解析 `input` 字段）
若需扫描 ERC20 Token 转账（如 USDT），修改 `parseBlockTransactions` 方法，解析交易 `input` 字段（ERC20 转账的核心信息存储在 `input` 中）：
```java
/**
 * 扩展：解析 ERC20 Token 转账交易
 */
private void parseErc20Transaction(EthBlock.TransactionObject tx, Long blockNumber) {
    String input = tx.getInput();
    // ERC20 transfer 方法签名：0xa9059cbb（前4字节）
    if (!input.startsWith("0xa9059cbb")) {
        return; // 非 ERC20 转账，跳过
    }

    // 解析 ERC20 接收地址（input 第34-74位，共40位）
    String erc20ToAddress = "0x" + input.substring(34, 74);
    if (!erc20ToAddress.equalsIgnoreCase(EXCHANGE_RECEIVE_ADDRESS)) {
        return;
    }

    // 解析转账金额（input 第74-138位，共64位，16进制转10进制）
    String amountHex = input.substring(74, 138);
    BigInteger amountWei = new BigInteger(amountHex, 16);
    // 转为 Token 实际金额（需传入 Token 精度，如 USDT 是 6 位）
    BigDecimal amount = new BigDecimal(amountWei).divide(BigDecimal.TEN.pow(6));

    // 封装并处理 ERC20 充值交易
    DepositDTO deposit = DepositDTO.builder()
            .txHash(tx.getHash())
            .fromAddress(tx.getFrom())
            .toAddress(erc20ToAddress)
            .amount(amount)
            .blockNumber(blockNumber)
            .coinSymbol("USDT")
            .build();
    depositHandler.handleDeposit(deposit);
}
```

#### 3. 生产环境优化要点
- 扫链日志持久化到数据库（`watcher_log` 表），避免重启后重复扫描；
- 增加双节点备份（如 Infura + Alchemy），节点故障自动切换；
- 幂等校验通过 `txHash` 查询数据库，避免重复处理；
- 交易确认数校验（ETH 主网需 12-30 个区块确认后再处理，防止交易回滚）。


### 五、运行说明
1. 替换 `Web3jConfig` 中的节点地址（Infura 需注册 API Key）；
2. 替换 `EXCHANGE_RECEIVE_ADDRESS` 为实际的交易所钱包地址；
3. 启动 Spring 应用，扫链服务会自动启动，日志输出扫描进度和充值交易。

该代码实现了扫链的核心闭环，结构清晰、无冗余，可作为交易所扫链服务的基础模板。

## 2.项目关键代码解释
### 1、项目文件
> rpc-common工程：
> 
> public abstract class Watcher implements Runnable{ }
> 
> public class DepositEvent { }
> 
> erc-ustd工程：
> 
> public class TokenWatcher extends Watcher{ }
> 
> eth工程：
> 
> public class EthWatcher extends Watcher{ }
>
### 2. 启动扫链

**rpc-common**工程：

```java
@Service
public class ApplicationEvent implements ApplicationListener<ContextRefreshedEvent> {
    private Logger logger = LoggerFactory.getLogger(ApplicationEvent.class);
    @Autowired
    private DepositEvent depositEvent;
    
    @Autowired(required = false)
    private Watcher watcher;
    @Autowired
    private Coin coin;
    @Autowired
    private WatcherLogService watcherLogService;
    @Autowired
    private WatcherSetting watcherSetting;

    @Override
    public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {
        if(watcher != null) {
            logger.info("=======Initialize Block Data Watcher=====");
            WatcherLog watcherLog = watcherLogService.findOne(coin.getName());
            logger.info("watcherLog:{}",watcherLog);
            if (watcherLog != null ) {
                watcher.setCurrentBlockHeight(watcherLog.getLastSyncHeight());
            } else if(watcherSetting.getInitBlockHeight().equalsIgnoreCase("latest")) {
                watcher.setCurrentBlockHeight(watcher.getNetworkBlockHeight());
            }else {
                Long height = Long.parseLong(watcherSetting.getInitBlockHeight());
                watcher.setCurrentBlockHeight(height);
            }
            //初始化参数
            //设置每次同步区块数量
            watcher.setStep(watcherSetting.getStep());
            //设置任务执行间隔
            watcher.setCheckInterval(watcherSetting.getInterval());
            watcher.setDepositEvent(depositEvent);
            //设置币种配置信息
            watcher.setCoin(coin);
            watcher.setWatcherLogService(watcherLogService);
            //设置交易需要的确认数
            watcher.setConfirmation(watcherSetting.getConfirmation());
            new Thread(watcher).start();
        }
        else{
            logger.error("=====启动程序失败=====");
        }
    }
}

```


### 3.扫描逻辑
Watcher.java文件：

```java
public void check(){
        try {
            logger.info("当前网络区块高度,"+getNetworkBlockHeight()+",当前扫描高度,"+currentBlockHeight);
            Long networkBlockNumber = getNetworkBlockHeight() - confirmation + 1;
            if (currentBlockHeight < networkBlockNumber) {
                long startBlockNumber = currentBlockHeight + 1;
                currentBlockHeight = (networkBlockNumber - currentBlockHeight > step) ? currentBlockHeight + step : networkBlockNumber;
                logger.info("replay block from {} to {}", startBlockNumber, currentBlockHeight);
                List<Deposit> deposits = replayBlock(startBlockNumber, currentBlockHeight);
                if(deposits != null) {
	        		deposits.forEach(deposit -> {
	                    depositEvent.onConfirmed(deposit);
	                });
	                //记录日志
	        		watcherLogService.update(coin.getName(), currentBlockHeight);
        		}else {
        			logger.info("扫块失败！！！");
        			// 未扫描成功
        			currentBlockHeight = startBlockNumber - 1;
        		}
            } else {
                logger.info("Already latest height: {}, networkBlockHeight: {},nothing to do!", currentBlockHeight, networkBlockNumber);
            }
        }
        catch (Exception e){
            e.printStackTrace();
        }
    }
```
#### 4.1 子类实现逻辑
TokenWatcher.java & EthWatcher.java 文件具体实现：
```java

/**
 * 将链上数据转换为Deposit对象，并返回
 */
public List<Deposit>  replayBlock(Long startBlockNumber, Long endBlockNumber) ;

/**
 * 返回区块高度
 */
public abstract Long getNetworkBlockHeight();
```

#### 4.2、获取区块链尖高度

TokenWatcher.java & EthWatcher.java 文件中：

```java
@Override
    public Long getNetworkBlockHeight() {
        try {
            EthBlockNumber blockNumber = web3j.ethBlockNumber().send();
            long networkBlockNumber = blockNumber.getBlockNumber().longValue();
            return networkBlockNumber;
        }
        catch (Exception e){
            e.printStackTrace();
            return 0L;
        }
    }
```

#### 4.3 开始区块计算公式
```java
Long networkBlockNumber = getNetworkBlockHeight() - confirmation + 1;
```

把「链尖」高度换算成 **「已经不可逆的区块高度」**（也叫 **安全高度** / **finalized height**）。  
各步含义：

1. `getNetworkBlockHeight()`  
   节点此刻看到的 **最新区块号**（链尖，tip）。

2. `- confirmation`  
   把指针往回挪 `confirmation` 个块，用来 **扣除尚有可能被重组（re-org）的区块**。  
   例如比特币常见 6 确认，以太坊常见 12/32 确认。

3. `+ 1`  
   因为区块号从 0 开始计数，**回退后需要再补 1** 才能拿到 **第一个被视为安全的区块号**。  
   举例：
    - 链高 100，要求 6 确认
    - 100 − 6 = 94 → 94 号区块及其之后都可能被重组
    - 因此 **95 号区块** 才是第一个安全块 → 100 − 6 + 1 = 95

结果：`networkBlockNumber` 就是业务代码可以 **放心承认** 的最高区块号，低于它的交易都认为 **已最终确定**，不会再被回滚。

### 4. 链上数据持久化

Watcher.java文件：
```java
@Component
public class DepositEvent {
    private Logger logger = LoggerFactory.getLogger(DepositEvent.class);
    @Autowired
    private DepositService depositService;
    @Autowired
    private KafkaTemplate<String, String> kafkaTemplate;
    @Value("${coin.name}")
    private String coinName;

    /**
     * synchronized 让多线程环境下同一时刻只能一个线程进入该方法，防止并发脏写
     */
    public synchronized void onConfirmed(Deposit deposit) {
        if (!depositService.exists(deposit)) {
            logger.info("confirmed deposit,tx={} address={} amount={}", deposit.getTxid(), deposit.getAddress(), deposit.getAmount());
            depositService.save(deposit);
            kafkaTemplate.send("deposit", coinName, JSON.toJSONString(deposit));
        }
    }
}
```















