## 1、Java中的锁到底是什么？

Java 中的锁 = **“让多线程排队访问共享资源”** 的一套机制，实现方式有两种：

1. **语言级**（synchronized）
   - 进入代码块即加锁，退出即解锁
   - JVM 依赖 **对象头里的 Monitor**（也叫“内置锁”）

2. **API 级**（java.util.concurrent.locks）
   - 手动加/解锁，如 `ReentrantLock.lock()` / `unlock()`
   - 基于 **AbstractQueuedSynchronizer（AQS）** 双向队列 + CAS 实现

一句话：锁就是 **“把并发变成串行”** 的工具，保证**原子性、可见性、有序性**。

## 2、是操作系统级别的东西，还是Java语言的设计？ 锁为什么被设计出来？

一句话：  
Java 里的锁是**语言封装**的，最终**借用了操作系统原语**；设计目的：把**并发踩坑三板斧**（竞态、脏读、乱序）一次解决。

---

### 1 到底是谁的锁？
| 层级          | 实现                            | 说明                                      |
| ------------- | ------------------------------- | ----------------------------------------- |
| **OS 内核**   | mutex、futex、semaphore         | 由操作系统调度，线程会**挂起/唤醒**       |
| **JVM**       | 对象头 Monitor、AQS             | 先用 CAS 自旋，实在不行才**调 OS 去睡眠** |
| **Java 代码** | `synchronized`、`ReentrantLock` | 只是**门面**，底层=JVM+OS组合拳           |

> 因此：Java 锁 = **语言设计 + 操作系统原语**的混合体；**用户代码不直接碰 OS API**。

---

### 2 为什么被设计出来？（让线程排队访问共享资源）
并发三大坑 → 锁一次性解决：

1. **竞态条件**（Race）  
   例：两个线程同时 `count++` 导致丢更新。  
   → 锁把“读-改-写”变成**串行**，原子性搞定。

2. **脏读/不可见**  
   例：线程 A 改完 `ready=true`，B 仍看到 `false`。  
   → 锁隐含**内存屏障**，保证**可见性**（Happens-Before）。

3. **指令重排**  
   例：单例模式 `new Instance()` 被重排，别人拿到**半初始化对象**。  
   → 锁屏障禁止**临界区内**重排，有序性得到。

---

### 3 背下来
> 锁是 Java 给程序员开的**“并发保险”**：**语法上只是关键字/类，骨子里靠 OS 挂线程；目的——让临界区代码像单线程一样安全执行。**

